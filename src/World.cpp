#include <algorithm>
#include "Engine/Log.hpp"
#include "World.hpp"
#include "Entity.hpp"

static CR::T_OBJID genObjId(){
    static std::mutex mutex;
    mutex.lock();
        static CR::T_OBJID start = CR::Math::random(25, 35);
        auto n = ++start;
    mutex.unlock();
    return n;
}

static CR::T_OBJID genWorldId(){
    static std::mutex mutex;
    mutex.lock();
        static CR::T_OBJID start = CR::Math::random(1001, 1099);
        auto n = ++start;
    mutex.unlock();
    return n;
}

CR::World::World(){
    this->currentTick = 0;
    this->puppetMode = false;
    this->wId = genWorldId();
    this->state = WorldState::IDLE;
    this->auditBacklog.push_back(this->createAudit(AuditType::GAME_SIM_START_OF_FRAME));  
    this->auditBacklog.push_back(this->createAudit(AuditType::GAME_SIM_CREATED));
}


void CR::World::start(){
    this->currentTick = 0;
    this->tickRate = 1000 / 60; // hardcoded for now
    if(!puppetMode){
        this->auditBacklog.push_back(this->createAudit(AuditType::GAME_SIM_STARTED));    
        setState(CR::WorldState::RUNNING); // manually start simulation for now  
    }else{
        this->auditBacklog.clear();
    }
    CR::log("World[%i]%s started simulation [%s]\n", this->wId, this->puppetMode ? "[P]" : "[M]", puppetMode ? "PUPPET" : "MASTER");    
}

void CR::World::reqEnd(){
     
}

std::shared_ptr<CR::Audit> CR::World::createAudit(CR::T_AUDIT type){
    auto audit = CR::createAudit(type);
    audit->state = state;
    audit->tick = this->currentTick;
    return audit;
}

std::shared_ptr<CR::Audit> CR::World::createAudit(const std::string &msg){
    auto audit = CR::createAudit(msg);
    audit->state = state;
    audit->tick = this->currentTick;
    return audit;
}


bool CR::World::isLocEmpty(CR::T_WORLDPOS x, CR::T_WORLDPOS y){

}

bool CR::World::isLocEmpty(CR::T_WORLDPOS index){

}

bool CR::World::apply(const std::shared_ptr<CR::Audit> &audit){ 
    audit->data.reset(); // audits generated by the server tend to come in "used", thus needing to reset the data's handle index
    switch(audit->type){
        /*
            PLAYER        
        */
        case CR::AuditType::PLAYER_CHAT_MESSAGE: {

        } break;
        case CR::AuditType::PLAYER_JOINED: {

        } break;

        case CR::AuditType::PLAYER_LEFT: {

        } break;

        case CR::AuditType::PLAYER_GRANT_ENTITY_CONTROL: {
            CR::T_OBJID entId;
            CR::T_GENERICID clId;
            entId = audit->affEnt[0];
            audit->data.read(&clId, sizeof(CR::T_GENERICID));
            #if CR_ENABLE_DEBUG_BUILD
                int eId = entId;
                CR::log("World[%i]%s Client '%i' was granted control over Entity '%i' \n", this->wId, this->puppetMode ? "[P]" : "[M]", clId, eId);    
            #endif            
        } break;  
        /*
            OBJECT  
        */
        case CR::AuditType::OBJECT_CREATED: {      
            CR::T_OBJID objId = audit->affEnt[0];
            CR::T_OBJSIG objSig;
            CR::T_WORLDPOS index, level;
            std::string name;
            
            audit->data.read(&objSig, sizeof(CR::T_OBJSIG));
            audit->data.read(&index, sizeof(CR::T_WORLDPOS));
            audit->data.read(&level, sizeof(CR::T_WORLDPOS));
            audit->data.read(name);
            switch(objSig){
                case ObjSigType::ENTITY: {
                    CR::T_ENTTYPE entType;
                    audit->data.read(&entType, sizeof(CR::T_ENTTYPE));
                    auto ent = std::make_shared<CR::Entity>(CR::Entity());
                    ent->world = this;
                    ent->name = name;
                    ent->build(entType);
                    // States are strictly managed by the server, thus objective functions such as this shouldn't run on puppetMode
                    // otherwise it opens the door for potential cl/sv desynchronization
                    if(!this->puppetMode){
                        ent->onCreate();   
                    }
                    this->objects.push_back(ent);
                    #if CR_ENABLE_DEBUG_BUILD
                        CR::log("World[%i]%s Created entity Id %i '%s': Type %i \n", this->wId, this->puppetMode ? "[P]" : "[M]", objId, name.c_str(), entType);    
                    #endif
                } break;
                case ObjSigType::PROP: {

                } break;     
                case ObjSigType::TRIGGER: {

                } break;  
                case ObjSigType::INTERACTABLE: {

                } break;                                            
            }

        } break;
        case CR::AuditType::OBJECT_DESTROYED: {
            CR::T_OBJID objId = audit->affEnt[0];
            auto obj = get(objId);
            if(obj->destroyed){
                #if CR_ENABLE_DEBUG_BUILD
                    CR::log("World[%i]%s Created Object Id %i is already marked for destruction \n", this->wId, this->puppetMode ? "[P]" : "[M]", objId);    
                #endif                
                break;
            }
            obj->destroyed = true;
            this->toRemObjs.push_back(objId);
            #if CR_ENABLE_DEBUG_BUILD
                CR::log("World[%i]%s Created Object Id %i was marked for destruction \n", this->wId, this->puppetMode ? "[P]" : "[M]", objId);  
            #endif                
        } break;
        case CR::AuditType::OBJECT_MOVED: {

        } break;                
        /*
            ENTITY  
        */
        case CR::AuditType::ENTITY_STATE_CHANGED: {

        } break;
        case CR::AuditType::ENTITY_STATUS_CHANGED: {

        } break;

        case CR::AuditType::ENTITY_DAMAGED: {

        } break;

        case CR::AuditType::ENTITY_KILLED: {

        } break;     

        case CR::AuditType::ENTITY_MOVED: {

        } break;                                
    }

    return true;
}


void CR::World::setState(T_STATE nstate){
    this->prevState = nstate;
    this->state = nstate;
    this->lastState = CR::ticks();
    auto audit = this->createAudit(AuditType::GAME_SIM_STATE_CHANGED);
    audit->state = nstate;
    this->auditBacklog.push_back(audit);
}

bool CR::World::run(const std::vector<std::shared_ptr<CR::Audit>> &audits){
    if(!puppetMode){ // this is only for the client to run
        CR::log("World[%i]%s run providing audits was used in non-puppetMode\n", this->wId, this->puppetMode ? "[P]" : "[M]");
        return false;
    }   
    // maybe add object onStep execution at current tick here?
    // We'll see if it's necessary since running these objective functions on the client can break synchronization
    for(unsigned i = 0; i < audits.size(); ++i){
        auto &audit = audits[i];
        this->currentTick = audit->tick;
        if(apply(audit)){
            this->auditHistory[audit->tick].push_back(audit);   
        }else{
            CR::log("World[%i]%s Fatal error has occured applying an audit: game will stop\n", this->wId, this->puppetMode ? "[P]" : "[M]");
            CR::Core::exit(1); // TODO: Find a better way to handle this. probably full resync?
            return false;
        }        
    }
    // Get rid of objects marked for destruction
    for(unsigned i = 0; i < this->toRemObjs.size(); ++i){
        // TODO: improve this
        for(unsigned j = 0; j < this->objects.size(); ++j){
            if(this->objects[j]->id == this->toRemObjs[i]){
                this->objects.erase(this->objects.begin() + j);
                break;
            }
        }
    }
    return true;
}

void CR::World::setPuppet(bool puppetMode, CR::T_OBJID wId){
    this->puppetMode = puppetMode;
    this->wId = wId;
}

bool CR::World::run(unsigned ticks){
    if(puppetMode){ // only for server
        CR::log("World[%i]%s run was used in puppetMode\n", this->wId, this->puppetMode ? "[P]" : "[M]");
        return false;
    }

    // apply floating audits (not generated by the simulation itself: ie external such as startup script)
    if(auditBacklog.size() > 0){
        for(unsigned i = 0; i < auditBacklog.size(); ++i){
            auto &audit = auditBacklog[i];
            if(audit->tick != currentTick){ continue; }
            audit->time = CR::ticks();
            audit->order = i;          
            if(apply(audit)){
                this->auditHistory[audit->tick].push_back(audit);   
            }else{
                CR::log("World[%i]%s Fatal error has occured applying an audit: game will stop\n", this->wId, this->puppetMode ? "[P]" : "[M]");
                CR::Core::exit(1); // TODO: Find a better way to handle this
                return false;
            }
        }
        auditBacklog.clear();
    }

    this->auditBacklog.push_back(this->createAudit(AuditType::GAME_SIM_END_OF_FRAME));       

    // run sim per tick
    for(unsigned i = 0; i < ticks; ++i){
        ++currentTick;
        for(unsigned i = 0; i < objects.size(); ++i){
            objects[i]->onStep();
        }
        totalSimTime += tickRate;
    }

    this->auditBacklog.push_back(this->createAudit(AuditType::GAME_SIM_START_OF_FRAME));

    std::sort(auditBacklog.begin(), auditBacklog.end(), [&](std::shared_ptr<CR::Audit> &a, std::shared_ptr<CR::Audit> &b) {
        return a->tick < b->tick;
    });   

    bool newChanges = auditBacklog.size() > 0;    

    // apply after audit after tick
    if(auditBacklog.size() > 0){
        for(unsigned i = 0; i < auditBacklog.size(); ++i){
            auto &audit = auditBacklog[i];
            audit->time = CR::ticks();
            audit->order = i;
            if(apply(audit)){
                this->auditHistory[audit->tick].push_back(audit);   
            }else{
                CR::log("World[%i]%s Fatal error has occured applying an audit: game will stop\n", this->wId, this->puppetMode ? "[P]" : "[M]");
                CR::Core::exit(1); // TODO: Find a better way to handle this
                return false;
            }
        }
        auditBacklog.clear();
    }
    
    return newChanges;
}

CR::T_OBJID CR::World::createEntity(const std::string &name, T_ENTTYPE type, const CR::GridLoc &loc){
    auto objId = genObjId();
    auto audit = this->createAudit(AuditType::OBJECT_CREATED);
    static const CR::T_OBJSIG sigType = ObjSigType::ENTITY;
    audit->affEnt.push_back(objId);
    audit->data.write(&sigType, sizeof(T_OBJSIG));
    audit->data.write(&loc.index, sizeof(T_WORLDPOS));
    audit->data.write(&loc.level, sizeof(T_WORLDPOS));
    audit->data.write(name);
    audit->data.write(&type, sizeof(T_ENTTYPE));
    this->auditBacklog.push_back(audit);
    return objId;
}

bool CR::World::exists(CR::T_OBJID id){
    for(unsigned i = 0; i < this->objects.size(); ++i){
        if(objects[i]->id == id){
            return true;
        }
    }
    return false;
}

std::shared_ptr<CR::Object> CR::World::get(CR::T_OBJID id){
    for(unsigned i = 0; i < this->objects.size(); ++i){
        if(this->objects[i]->id == id){
            return this->objects[i];
        }
    }
    return std::shared_ptr<CR::Object>(NULL);
}

bool CR::World::destroy(T_OBJID id){
    auto audit = this->createAudit(AuditType::OBJECT_DESTROYED);
    audit->affEnt.push_back(id);
    this->auditBacklog.push_back(audit);
    return id;
}

void CR::World::render(const CR::Vec2<unsigned> &offset){
    static auto gameLayer = CR::Gfx::getRenderLayer("world", true);
    // Objects from world are rendered on the overworld directly
    gameLayer->renderOn([&](CR::Gfx::RenderLayer *layer){    
        for(unsigned i = 0; i < this->objects.size(); ++i){
            this->objects[i]->draw();
        }
    });   
}